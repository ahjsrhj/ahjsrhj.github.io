<!DOCTYPE html><html lang=zh-CN><head><meta name=generator content="Hexo 3.9.0"><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><title>面试的可能知识点总结 · Hexer</title><meta name=description content="面试的可能知识点总结 - Hexer"><meta name=viewport content="width=device-width, initial-scale=1"><link rel=icon href=https://i.loli.net/2018/12/05/5c07807cb76f9.png><link rel=stylesheet href=/css/apollo.css><link rel=search type=application/opensearchdescription+xml href=https://imrhj.cn/atom.xml title=Hexer></head><body><div class=wrap><header><a href="/" class=logo-link><img src=https://i.loli.net/2018/12/05/5c07807cb76f9.png alt=logo></a><ul class="nav nav-list"><li class=nav-list-item><a href="/" target=_self class=nav-list-link>BLOG</a></li><li class=nav-list-item><a href="/archives/" target=_self class=nav-list-link>ARCHIVE</a></li><li class=nav-list-item><a href="/about/" target=_self class=nav-list-link>ABOUT</a></li><li class=nav-list-item><a href=https://github.com/ahjsrhj target=_blank class=nav-list-link>GITHUB</a></li><li class=nav-list-item><a href="/friend/" target=_self class=nav-list-link>FRIEND</a></li></ul><script src=/js/canvas-nest-check.js></script></header><main class=container><div class=post><article class=post-block><h1 class=post-title>面试的可能知识点总结</h1><div class=post-info>2016年4月18日</div><div class=post-content><p><img src=https://i.loli.net/2019/06/14/5d0397968d9e384940.png alt=1560516499989.png></p><a id=more></a><h1 id=1-Java对象大小与引用的大小><a href=#1-Java对象大小与引用的大小 class=headerlink title="1. Java对象大小与引用的大小"></a>1. Java对象大小与引用的大小</h1><p><a href="http://www.liaohuqiu.net/cn/posts/caculate-object-size-in-java/" target=_blank rel=noopener>来源</a></p><p>一个实例化的对象在内存中需要存储的信息包括：</p><ul><li>对象的头部(对象的GC信息，hash值，类定义引用等)</li><li>对象的成员变量: 包括基本数据类型和引用。 如成员变量是一个引用, 引用了其他对象，被引用的对象内存另外计算。</li></ul><h2 id=1-1-对象的大小><a href=#1-1-对象的大小 class=headerlink title="1.1 对象的大小"></a>1.1 对象的大小</h2><p>一个对象的大小其中包含:</p><ul><li>自身的大小<blockquote><p>直接计算当前对象占用空间大小，包括当前类及超类的基本类型实例字段大小、引用类型实例字段引用大小、实例基本类型数组总占用空间、实例引用类型数组引用本身占用空间大小</p></blockquote></li><li>所引用对象的大小</li></ul><h2 id=1-2-引用的大小><a href=#1-2-引用的大小 class=headerlink title="1.2 引用的大小"></a>1.2 引用的大小</h2><p>在32位JVM上，一个对象引用占用4字节，64位上，占8个字节。</p><blockquote><p>如果不需要访问超过4G内存，可以通过<code>-XX:+UseCompressedOops</code>选项开启指针压缩。从<strong>Java 1.6.0_23</strong>开始，这个选项默认是开启的。</p></blockquote><hr><p>比如下面一个简单的类:<br><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>MyClass</span> </span>&#123;</span><br><span class=line>	<span class=keyword>int</span> a;</span><br><span class=line>	Object object;</span><br><span class=line>&#125;</span><br><span class=line>MyClass myClass = <span class=keyword>new</span> MyClass();</span><br></pre></td></tr></table></figure></p><p>创建一个<strong>myClass</strong>实例之后，首先需要在栈空间中分配一个地址空间，即引用，引用的大小视虚拟机平台，32位为4字节，64位为8字节<em>在开启指针压缩的情况下为4字节</em>。之后在堆空间中分配对象的类变量信息。本例中包括类的头部+一个int类型数值+一个引用类型。</p><h2 id=1-3-基本数据类型大小><a href=#1-3-基本数据类型大小 class=headerlink title="1.3 基本数据类型大小"></a>1.3 基本数据类型大小</h2><table><thead><tr><th style=text-align:center>类型</th><th style=text-align:center>大小(位)</th><th style=text-align:center>大小(字节)</th><th style=text-align:center>范围</th></tr></thead><tbody><tr><td style=text-align:center>boolean*</td><td style=text-align:center>8</td><td style=text-align:center>1</td><td style=text-align:center>true/false</td></tr><tr><td style=text-align:center>byte</td><td style=text-align:center>8</td><td style=text-align:center>1</td><td style=text-align:center>-128 - 127</td></tr><tr><td style=text-align:center>char*</td><td style=text-align:center>16</td><td style=text-align:center>2</td><td style=text-align:center>0 - 65535</td></tr><tr><td style=text-align:center>short</td><td style=text-align:center>16</td><td style=text-align:center>2</td><td style=text-align:center>-32768 - 23767</td></tr><tr><td style=text-align:center>int</td><td style=text-align:center>32</td><td style=text-align:center>4</td><td style=text-align:center>-2147483648 - 2147483647</td></tr><tr><td style=text-align:center>long</td><td style=text-align:center>64</td><td style=text-align:center>8</td><td style=text-align:center>-9223372036854775808 - 9223372036854775807</td></tr><tr><td style=text-align:center>float</td><td style=text-align:center>32</td><td style=text-align:center>4</td><td style=text-align:center>-3.4E38 - 3.4E38</td></tr><tr><td style=text-align:center>double</td><td style=text-align:center>64</td><td style=text-align:center>8</td><td style=text-align:center>-1.7E308 - 1.7E308</td></tr></tbody></table><blockquote><p>需要注意的是，boolean类型在内存中实际使用的只有一字节的最低位，其余位全置0。因为内存处理以字节(<strong>byte</strong>)为单位，而不是位(<strong>bit</strong>)。char类型从字符型对应的整型数来划分，其表示范围是0 - 65535</p></blockquote><h2 id=1-4-对象头部大小><a href=#1-4-对象头部大小 class=headerlink title="1.4 对象头部大小"></a>1.4 对象头部大小</h2><p>对象头结构如下<a href=http://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2008-May/000147.html target=_blank rel=noopener>来源</a></p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>mark word</th><th style=text-align:center>class pointer</th><th style=text-align:center>array size (opt)</th><th style=text-align:center>padding</th></tr></thead><tbody><tr><td style=text-align:center><strong>32位</strong></td><td style=text-align:center>4byte</td><td style=text-align:center>4byte</td><td style=text-align:center><del>4byte</del></td><td style=text-align:center></td></tr><tr><td style=text-align:center><strong>64位+UseCompressedOops</strong></td><td style=text-align:center>8byte</td><td style=text-align:center>4byte</td><td style=text-align:center><del>4byte</del></td><td style=text-align:center></td></tr><tr><td style=text-align:center><strong>64位-UseCompressedOops</strong></td><td style=text-align:center>8byte</td><td style=text-align:center>8byte</td><td style=text-align:center><del>4byte</del></td></tr></tbody></table><blockquote><p>每个对象都有一个mark work头部，以及一个引用，指向类的信息。在32位JVM上，markword 4个字节，整个头部有8字节大小。</p></blockquote><blockquote><p>array size(opt)在对象为数组的时候启用，4字节（4byte）长度。JVM规定对象头（Object Header）长度为2个字（word），在32bit JVM中，一个word长度为4byte，64bit JVM中，长度为8byte</p></blockquote><blockquote><p>在未开启UseCompressedOops的64位JVM上，对象头有16字节大小。</p></blockquote><blockquote><p>在开启UseCompressedOops的64位机器上，引用（class pointer）成了4字节，一共12字节。按照8位对齐，实际占用16字节。</p></blockquote><h2 id=1-5-数组内存占用大小><a href=#1-5-数组内存占用大小 class=headerlink title="1.5 数组内存占用大小"></a>1.5 数组内存占用大小</h2><p>数组在内存中也是以引用形式存在，所以也有对象的头部，数组还有一个记录数组长度的int类型，随后是每一个数组的元素：基本数据类型或引用类型。也按照8字节对齐。</p><ul><li><strong>32位机器</strong><blockquote><p>byte[0] 12字节的对象头部(<em>mark word: 4byte, class pointer: 4byte, array size: 4byte</em>),对齐后是16字节。实际 byte[0] ~byte[4]都是16字节(每个byte的长度为1byte，byte[0]-byte[4]占用padding长度)。</p></blockquote></li><li><strong>64位+UseCompressedOops</strong><blockquote><p>byte[0] 16字节的对象头部(<em>mark word: 8byte, class pointer: 4byte, array size: 4byte</em>),byte<a href=https://i.loli.net/2018/09/30/5bb06c7783b27.png target=_blank rel=noopener>1</a> ~byte[8] 24字节大小。</p></blockquote></li><li><strong>64 位-UseCompressedOops</strong><blockquote><p>byte[0] 20字节的对象头部(<em>mark word: 8byte, class pointer: 8byte, array size: 4byte</em>),对齐后是24字节。byte[0] ~ byte[4] 都是24字节。</p></blockquote></li></ul><h1 id=2-单链表><a href=#2-单链表 class=headerlink title="2. 单链表"></a>2. 单链表</h1><p><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target=_blank rel=noopener>参考1</a> <a href=http://blog.sina.com.cn/s/blog_725dd1010100tqwp.html target=_blank rel=noopener>参考2</a></p><p>给定一个单链表，只给出头指针head：</p><ol><li>如何判断是否存在环？</li><li>如何知道环的长度？</li><li>如何找出环的连接点在哪里？</li><li>带环链表的长度是多少？</li><li>单链表转置</li><li>求链表倒数第k个节点</li><li>求链表的中间节点</li><li>在O(1)时间删除链表节点</li></ol><h2 id=2-1-判断一个单链表是否有环><a href=#2-1-判断一个单链表是否有环 class=headerlink title="2.1 判断一个单链表是否有环"></a>2.1 判断一个单链表是否有环</h2><p><strong>题目描述:</strong> 输入一个单向链表，判断链表是否有环？</p><p><strong>题目分析:</strong></p><p>对于这个问题，使用追赶的方法，设置两个头指针<code>fast</code> <code>slow</code>，每次让<code>high</code>移动两个位置，<code>low</code>移动一个位置，如果有环的话，两个肯定会有相等的时候，如果high指针最后为空则说明没有环。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>bool</span> <span class=title>isExistLoop</span><span class=params>(Node *head)</span> </span>&#123;</span><br><span class=line>	Node *fast = head;</span><br><span class=line>	Node *slow = head;</span><br><span class=line>	<span class=keyword>while</span> (fast != <span class=literal>NULL</span> &amp;&amp; fast-&gt;next != <span class=literal>NULL</span>) &#123;</span><br><span class=line>		slow = slow-&gt;next;</span><br><span class=line>		fast = fast-&gt;next-&gt;next;</span><br><span class=line>		<span class=keyword>if</span> (slow == fast)</span><br><span class=line>			<span class=keyword>return</span> TRUE;</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=keyword>return</span> FALSE;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=2-2-如何知道环的长度><a href=#2-2-如何知道环的长度 class=headerlink title="2.2 如何知道环的长度"></a>2.2 如何知道环的长度</h2><p><strong>题目描述:</strong> 输入一个单链表，如果单链表存在环，环的长度是多少？</p><p><strong>题目分析:</strong></p><p>首先确定问题1里两个指针相遇的节点，记录下这个节点，之后让其中一个再跑一圈，再次碰撞走过的步数就是环的长度。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>int</span> <span class=title>getLoopLength</span><span class=params>(Node *head)</span> </span>&#123;</span><br><span class=line>	Node *fast = head;</span><br><span class=line>	Node *slow = head;</span><br><span class=line>	<span class=keyword>int</span> sum = <span class=number>0</span>;</span><br><span class=line>	<span class=keyword>while</span> (fast != <span class=literal>NULL</span> &amp;&amp; fast-&gt;next != <span class=literal>NULL</span>) &#123;</span><br><span class=line>		slow = slow-&gt;next;</span><br><span class=line>		fast = fast-&gt;next-&gt;next;</span><br><span class=line>		<span class=keyword>if</span> (fast == slow)</span><br><span class=line>			<span class=keyword>break</span>;</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=keyword>if</span> (fast != slow) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>	<span class=keyword>do</span> &#123;</span><br><span class=line>		fast = fast-&gt;next;</span><br><span class=line>		sum++;</span><br><span class=line>	&#125; <span class=keyword>while</span> (fast != slow);</span><br><span class=line>	<span class=keyword>return</span> sum;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=2-3-如何找出环的连接点在哪里？><a href=#2-3-如何找出环的连接点在哪里？ class=headerlink title="2.3 如何找出环的连接点在哪里？"></a>2.3 如何找出环的连接点在哪里？</h2><p><strong>题目描述:</strong> 输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的连接点？</p><p><strong>题目分析:</strong><br>首先确定链表有没有环，如果有环的话，让<code>fast</code>指针从头节点重新走一遍，走的步长为1，同时让<code>slow</code>节点从当前位置继续前进，当两个节点再次相遇时，所在的节点即是环的<strong>连接点</strong>。<br>有定理如下：</p><blockquote><p>碰撞点p到连接点的距离=头指针到连接点的距离，因此，分别从碰撞点、头指针开始走，相遇的那个点就是连接点。</p></blockquote><p><strong>推导:</strong> 假设从头结点到环连接点的距离为a，从连接点到碰撞点的距离为b，圆周距离为L，那么从两个指针出发到碰撞，两个指针分别走过的路程为:</p><ul><li><code>fast</code> : <code>a + b + k * L = 2n</code></li><li><code>slow</code> : <code>a + b = n</code></li></ul><p>又因为<code>fast</code>指针所走过的路程为<code>slow</code>指针所走路程的2倍：<code>a + b = k * L = n</code> 。所以一个指针从头结点出发，另一个从碰撞点出发，经过n步之后，还可以到达碰撞点。因为b这段距离是在环内走的，所以只有a这段是不同的，当两个指针再次重合时，必然是在连接点。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=function>Node* <span class=title>findLoopPoint</span><span class=params>(Node *head)</span> </span>&#123;</span><br><span class=line>	Node *fast = head;</span><br><span class=line>	Node *slow = head;</span><br><span class=line>	<span class=keyword>while</span> (fast != <span class=literal>NULL</span> &amp;&amp; fast-&gt;next != <span class=literal>NULL</span>) &#123;</span><br><span class=line>		slow = slow-&gt;next;</span><br><span class=line>		fast = fast-&gt;next-&gt;next;</span><br><span class=line>		<span class=keyword>if</span> (slow == fast)</span><br><span class=line>			<span class=keyword>break</span>;</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=keyword>if</span> (fast != slow) <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>  	fast = head;</span><br><span class=line>  	<span class=keyword>while</span> (fast != slow) &#123;</span><br><span class=line>  		fast = fast-&gt;next;</span><br><span class=line>      	slow = slow-&gt;next;</span><br><span class=line>    &#125;</span><br><span class=line>  	<span class=keyword>return</span> fast;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=2-4-带环链表的长度是多少？><a href=#2-4-带环链表的长度是多少？ class=headerlink title="2.4 带环链表的长度是多少？"></a>2.4 带环链表的长度是多少？</h2><p><strong>题目描述:</strong> 输入一个单向链表，判断链表是否有环。如果链表存在环，链表的长度是多少?</p><p><strong>题目分析:</strong></p><p>使用问题2中获得的环的长度加上问题三中环的连接点位置，即为链表的长度。</p><p><del>代码省略</del></p><h2 id=2-5-单链表转置><a href=#2-5-单链表转置 class=headerlink title="2.5 单链表转置"></a>2.5 单链表转置</h2><p><strong>题目描述：</strong>输入一个单向链表，输出逆序反转后的链表</p><p><strong>题目分析：</strong></p><p>链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 单链表的转置，循环方法</span></span><br><span class=line><span class=function>Node* <span class=title>reverse</span><span class=params>(Node *head)</span> </span>&#123;</span><br><span class=line>  	<span class=keyword>if</span> (head == <span class=literal>NULL</span> || head-&gt;next == <span class=literal>NULL</span>) <span class=keyword>return</span> head;</span><br><span class=line>  	Node *pre = <span class=literal>NULL</span>;</span><br><span class=line>  	Node *next = <span class=literal>NULL</span>;</span><br><span class=line>  	<span class=keyword>while</span> (head != <span class=literal>NULL</span>) &#123;</span><br><span class=line>  		next = head-&gt;next;</span><br><span class=line>      	head-&gt;next = pre;</span><br><span class=line>      	pre = head;</span><br><span class=line>      	head = next;</span><br><span class=line>	&#125;</span><br><span class=line>  	<span class=keyword>return</span> pre;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>// 递归方法</span></span><br><span class=line><span class=function>Node* <span class=title>reverseByRecursion</span><span class=params>(Node *head)</span> </span>&#123;</span><br><span class=line>  	<span class=keyword>if</span> (head == <span class=literal>NULL</span> || head-&gt;next == <span class=literal>NULL</span>) <span class=keyword>return</span> head;</span><br><span class=line>  	Node *phead = reverseByRecursion(head-&gt;next);</span><br><span class=line>  	head-&gt;next-&gt;next = haed;</span><br><span class=line>  	head-&gt;next = <span class=literal>NULL</span>;</span><br><span class=line>  	<span class=keyword>return</span> phead;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=2-6-求链表倒数第k个节点><a href=#2-6-求链表倒数第k个节点 class=headerlink title="2.6 求链表倒数第k个节点"></a>2.6 求链表倒数第k个节点</h2><p><strong>题目描述：</strong> 给定一个单链表，设计一个时间和空间都高效的算法来找到链表的倒数第k个元素。当k=0时，返回链表的最后一个元素。</p><p><strong>题目分析:</strong></p><p>设置两个指针，指向当前位置的指针和前m个元素的指针。在遍历的时候做统计， 当第一个指针移动m个时，同时移动第二个指针。当链表长度小于m时，如果不进行处理，很容易引起空指针异常。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=function>Node* <span class=title>FindKToLastElement</span><span class=params>(Node *head, <span class=keyword>int</span> k)</span> </span>&#123;</span><br><span class=line>  	<span class=keyword>if</span> (k &lt; <span class=number>0</span>) <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>  	Node *p1, *p2;</span><br><span class=line>  	p1 = head;</span><br><span class=line>  	<span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i&lt; k; i++) &#123;</span><br><span class=line>  		<span class=keyword>if</span> (p1-&gt;next != <span class=literal>NULL</span>) &#123;</span><br><span class=line>  			p1 = p1-&gt;next;</span><br><span class=line>  		&#125; <span class=keyword>else</span> &#123;</span><br><span class=line>  			<span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>        &#125;</span><br><span class=line>	&#125;</span><br><span class=line>  	p2 = head;</span><br><span class=line>  	<span class=keyword>while</span> (p1-&gt;next != <span class=literal>NULL</span>) &#123;</span><br><span class=line>  		p1 = p1-&gt;next;</span><br><span class=line>      	p2 = p2-&gt;next;</span><br><span class=line>    &#125;</span><br><span class=line>  	<span class=keyword>return</span> p2;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=2-7-求链表的中间节点><a href=#2-7-求链表的中间节点 class=headerlink title="2.7 求链表的中间节点"></a>2.7 求链表的中间节点</h2><p><strong>题目描述：</strong>求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p><p><strong>题目分析：</strong></p><p>此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=function>Node* <span class=title>theMiddleNode</span><span class=params>(Node *head)</span> </span>&#123;</span><br><span class=line>  	<span class=keyword>if</span> (head == <span class=literal>NULL</span>) <span class=keyword>return</span> <span class=literal>NULL</span>;</span><br><span class=line>  	Node *slow = head;</span><br><span class=line>  	Node *fast = head;</span><br><span class=line>  	<span class=keyword>while</span> (fast != null &amp;&amp; fast-&gt;next != <span class=literal>NULL</span>) &#123;</span><br><span class=line>  		fast = fast-&gt;next-&gt;next;</span><br><span class=line>      	slow = fast-&gt;next;</span><br><span class=line>    &#125;</span><br><span class=line>  	<span class=keyword>return</span> slow;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=2-8-在O-1-时间删除链表节点><a href=#2-8-在O-1-时间删除链表节点 class=headerlink title="2.8 在O(1)时间删除链表节点"></a>2.8 在O(1)时间删除链表节点</h2><p><strong>题目描述：</strong>给定链表的头指针和一个节点指针，在O(1)时间删除该节点。[Google面试题]</p><p><strong>分析：</strong></p><p>本题与《编程之美》上的「从无头单链表中删除节点」类似。主要思想都是「狸猫换太子」，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>deleteRandomNode</span><span class=params>(Node *cur)</span> </span>&#123;</span><br><span class=line>  	assert(cur != <span class=literal>NULL</span>);</span><br><span class=line>	assert(cur-&gt;next != <span class=literal>NULL</span>);</span><br><span class=line>  	Node pNext = cur-&gt;next;</span><br><span class=line>  	cur-&gt;data = pNext-&gt;data;</span><br><span class=line>  	cur-&gt;next = pNext-&gt;next;</span><br><span class=line>  	<span class=keyword>delete</span> next;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h1 id=3-JAVA><a href=#3-JAVA class=headerlink title=3.JAVA></a>3.JAVA</h1><h2 id=3-1-JAVA虚拟机><a href=#3-1-JAVA虚拟机 class=headerlink title="3.1 JAVA虚拟机"></a>3.1 JAVA虚拟机</h2><ol><li>原子性</li><li>可见性</li><li>有序性</li></ol><h3 id=3-1-1-原子性><a href=#3-1-1-原子性 class=headerlink title="3.1.1 原子性"></a>3.1.1 原子性</h3><blockquote><p>​ 原子性就是一个操作（可能是需要多步完成的复合操作）不能被打断，一旦开始执行直到执行完其他线程或多核都必须等待。比如”i++”表达式，就不是原子的，汇编后会发现由三条指令（读取，修改，写入）完成，每一条指令完成后都可能被中断。</p></blockquote><p>由Java内存模型来直接保证的原子性变量操作包括<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了<code>lock</code>和<code>unlock</code>操作来满足这种需求，尽管虚拟机未把<code>lock</code>与<code>unlock</code>操作直接开放给用户使用，但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—<code>synchronized</code>关键字，因此在<code>synchronized</code>块之间的操作也具备原子性。</p><h2 id=3-2-Object中的方法><a href=#3-2-Object中的方法 class=headerlink title="3.2 Object中的方法"></a>3.2 Object中的方法</h2><p>如下，共有9种方法。</p><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> Class&lt;?&gt; getClass();</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>native</span> <span class=keyword>int</span> <span class=title>hashCode</span><span class=params>()</span></span>;</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>equals</span><span class=params>(Object obj)</span> </span>&#123;</span><br><span class=line>        <span class=keyword>return</span> (<span class=keyword>this</span> == obj);</span><br><span class=line>&#125;</span><br><span class=line><span class=function><span class=keyword>protected</span> <span class=keyword>native</span> Object <span class=title>clone</span><span class=params>()</span> <span class=keyword>throws</span> CloneNotSupportedException</span>;</span><br><span class=line><span class=function><span class=keyword>public</span> String <span class=title>toString</span><span class=params>()</span> </span>&#123;</span><br><span class=line>        <span class=keyword>return</span> getClass().getName() + <span class=string>"@"</span> + Integer.toHexString(hashCode());</span><br><span class=line>&#125;</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> <span class=keyword>void</span> <span class=title>notify</span><span class=params>()</span></span>;</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> <span class=keyword>void</span> <span class=title>notifyAll</span><span class=params>()</span></span>;</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> <span class=keyword>void</span> <span class=title>wait</span><span class=params>(<span class=keyword>long</span> timeout)</span> <span class=keyword>throws</span> InterruptedException</span>;</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>void</span> <span class=title>wait</span><span class=params>(<span class=keyword>long</span> timeout, <span class=keyword>int</span> nanos)</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (timeout &lt; <span class=number>0</span>) &#123;</span><br><span class=line>		<span class=keyword>throw</span> <span class=keyword>new</span> IllegalArgumentException(<span class=string>"timeout value is negative"</span>);</span><br><span class=line>    &#125;</span><br><span class=line>	<span class=keyword>if</span> (nanos &lt; <span class=number>0</span> || nanos &gt; <span class=number>999999</span>) &#123;</span><br><span class=line>		<span class=keyword>throw</span> <span class=keyword>new</span> IllegalArgumentException(<span class=string>"nanosecond timeout value out of range"</span>);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=keyword>if</span> (nanos &gt; <span class=number>0</span>) &#123;</span><br><span class=line>		timeout++;</span><br><span class=line>	&#125;</span><br><span class=line>	wait(timeout);</span><br><span class=line>&#125;</span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>void</span> <span class=title>wait</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	wait(<span class=number>0</span>);</span><br><span class=line>&#125;</span><br><span class=line> <span class=function><span class=keyword>protected</span> <span class=keyword>void</span> <span class=title>finalize</span><span class=params>()</span> <span class=keyword>throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ol><li><code>getClass():</code> 返回此 Object 的运行时类。</li><li><code>hashCode():</code> 返回该对象的哈希值。</li><li><code>equals():</code> 指示其他某个对象是否与此对象“相等”。</li><li><code>clone():</code> 创建并返回此对象的一个副本。</li><li><code>toString():</code> 返回对象的字符串表示。</li><li><code>notify():</code> 唤醒在次对象监视器上等待的单个线程<em>(注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级)</em>。</li><li><code>ntifyAll():</code> 唤醒在此对象监视器上等待的所有线程。</li><li><code>wait():</code> 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。</li><li><code>finalize():</code> 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</li></ol><h1 id=4-排序算法><a href=#4-排序算法 class=headerlink title="4. 排序算法"></a>4. 排序算法</h1><h2 id=4-1-直接选择排序-不稳定><a href=#4-1-直接选择排序-不稳定 class=headerlink title="4.1 直接选择排序: 不稳定"></a>4.1 直接选择排序: <em>不稳定</em></h2><h3 id=4-1-1-说明><a href=#4-1-1-说明 class=headerlink title="4.1.1 说明"></a>4.1.1 说明</h3><center><strong>效果图:</strong> <img src=https://i.loli.net/2018/09/30/5bb06cc8e5de2.gif alt=sort1></center><p>直接选择排序(Straight Select Sorting) 也是一种简单的排序方法，它的基本思想是：第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，第二次从R<a href=https://i.loli.net/2018/09/30/5bb06c7783b27.png target=_blank rel=noopener>1</a>~R[n-1]中选取最小值，与R<a href=https://i.loli.net/2018/09/30/5bb06c7783b27.png target=_blank rel=noopener>1</a>交换，….，第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，…..，第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列·</p><h3 id=4-1-2-代码><a href=#4-1-2-代码 class=headerlink title="4.1.2 代码"></a>4.1.2 代码</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>SelectSort</span><span class=params>(elemtype R[], <span class=keyword>int</span> n)</span> </span>&#123;</span><br><span class=line>	<span class=keyword>int</span> i, j, m;</span><br><span class=line>	elemtype t;</span><br><span class=line>	<span class=keyword>for</span>(i=<span class=number>0</span>; i&lt;n<span class=number>-1</span>; i++) &#123;</span><br><span class=line>		m = i;</span><br><span class=line>		<span class=keyword>for</span>(j = i+<span class=number>1</span>; j &lt; n; j++) &#123;</span><br><span class=line>			<span class=keyword>if</span>(R[j] &lt; R[m])</span><br><span class=line>				m = j;</span><br><span class=line>		&#125;</span><br><span class=line>		<span class=keyword>if</span>(m != i) &#123;</span><br><span class=line>			t = R[i];</span><br><span class=line>			R[i] = R[m];</span><br><span class=line>			R[m] = t;</span><br><span class=line>		&#125;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=4-1-3-效率分析><a href=#4-1-3-效率分析 class=headerlink title="4.1.3 效率分析"></a>4.1.3 效率分析</h3><blockquote><p>在直接选择排序中，共需要进行n-1次选择和交换，每次选择需要进行 n-i 次比较 (1&lt;=i&lt;=n-1),而每次交换最多需要3次移动，因此，总的比较次数C=(n*n - n)/2,总的移动次数 3(n-1).由此可知，直接选择排序的时间复杂度为 O(n2) (n的平方)，所以当记录占用字节数较多时，通常比 直接插入排序的执行速度快些。</p><p>由于在直接选择排序中存在着不相邻元素之间的互换，因此，直接选择排序是一种不稳定的排序方法。</p></blockquote><h2 id=4-2-直接插入排序-稳定><a href=#4-2-直接插入排序-稳定 class=headerlink title="4.2 直接插入排序:稳定"></a>4.2 直接插入排序:<em>稳定</em></h2><h3 id=4-2-1-说明><a href=#4-2-1-说明 class=headerlink title="4.2.1 说明"></a>4.2.1 说明</h3><center><img src=https://i.loli.net/2018/09/30/5bb06ce8d30ec.gif alt=sort2></center><p>插入排序的基本方法是：每步将一个待排序的记录按其关键字的大小插到前面已经排序的序列中的适当位置，直到全部记录插入完毕为止。</p><p>具体实现有两种方法:</p><ol><li><p>简单方法</p><pre><code>&gt; 首先在当前有序区R[1..i-1]中查找R[i]的正确插入位置k(1≤k≤i-1)；然后将R[k．．i-1]中的记录均后移一个位置，腾出k位置上的空间插入R[i]。
</code></pre></li><li><p>改进的方法</p><blockquote><p>一种查找比较操作和记录移动操作交替地进行的方法。具体做法：<br>将待插入记录R[i]的关键字从右向左依次与有序区中记录R<a href="j=i-1，i-2，…，1">j</a>的关键字进行比较：<br>① 若R[j]的关键字大于R[i]的关键字，则将R[j]后移一个位置；<br>②若R[j]的关键字小于或等于R[i]的关键字，则查找过程结束，j+1即为R[i]的插入位置。<br>关键字比R[i]的关键字大的记录均已后移，所以j+1的位置已经腾空，只要将R[i]直接插入此位置即可完成一趟直接插入排序。</p></blockquote></li></ol><p>算法中引进的附加记录L[0]称监视哨或哨兵(Sentinel)。哨兵有两个作用：</p><ol><li>进人查找(插入位置)循环之前，它保存了L[i]的副本，使不致于因记录后移而丢失L[i]的内容；</li><li>它的主要作用是：在查找循环中”监视”下标变量j是否越界。一旦越界(即j=0)，因为L[0].可以和自己比较，循环判定条件不成立使得查找循环结束，从而避免了在该循环内的每一次均要检测j是否越界(即省略了循环判定条件”j&gt;=1”)。</li></ol><h3 id=4-2-2-代码><a href=#4-2-2-代码 class=headerlink title="4.2.2 代码"></a>4.2.2 代码</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>InsertSort</span><span class=params>(SqList &amp;L)</span> </span>&#123;</span><br><span class=line>  	<span class=keyword>int</span> i, j;</span><br><span class=line> 	<span class=keyword>for</span> (i = <span class=number>2</span>; i &lt;= L.leight; i++) &#123;</span><br><span class=line>  		<span class=keyword>if</span> (L.r[i].key &lt; L.r[i<span class=number>-1</span>].key) &#123;</span><br><span class=line>  			L.r[<span class=number>0</span>] = L.r[i];</span><br><span class=line>      		L.r[i] = L.r[i - <span class=number>1</span>];</span><br><span class=line>			<span class=keyword>for</span> (j = i - <span class=number>2</span>; L.r[<span class=number>0</span>].key &lt; L.r[j].key; j--) &#123;</span><br><span class=line>  				L.r[j+<span class=number>1</span>] = L.r[j];</span><br><span class=line>			&#125;</span><br><span class=line>        &#125;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=4-2-3-效率分析><a href=#4-2-3-效率分析 class=headerlink title="4.2.3 效率分析"></a>4.2.3 效率分析</h3><blockquote><p>从空间来看，直接插入排序仅需要一个记录的辅助空间。</p><p>从时间来看，其时间复杂度为<code>O(n^2)</code>。</p></blockquote><h2 id=4-3-折半插入排序-稳定><a href=#4-3-折半插入排序-稳定 class=headerlink title="4.3 折半插入排序: 稳定"></a>4.3 折半插入排序: <em>稳定</em></h2><h3 id=4-3-1-说明><a href=#4-3-1-说明 class=headerlink title="4.3.1 说明"></a>4.3.1 说明</h3><p>折半插入排序（binary insertion sort）是对<code>插入排序</code>算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。</p><h3 id=4-3-2-代码><a href=#4-3-2-代码 class=headerlink title="4.3.2 代码"></a>4.3.2 代码</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>BInsertSort</span><span class=params>(SqList &amp;L)</span> </span>&#123;</span><br><span class=line>	<span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>2</span>; i &lt;= L.lenght; i++) &#123;</span><br><span class=line>  		L.r[<span class=number>0</span>] = L.r[i];</span><br><span class=line>      	low = <span class=number>1</span>; high = i - <span class=number>1</span>;</span><br><span class=line>      	<span class=keyword>while</span> (low &lt;= high) &#123;</span><br><span class=line>  			m = (low + high) / <span class=number>2</span>;</span><br><span class=line>          	<span class=keyword>if</span> (L.r[<span class=number>0</span>].key &lt; L.r[m].key) &#123;</span><br><span class=line>         		<span class=comment>//折半区在低半区</span></span><br><span class=line>  				high = m - <span class=number>1</span>;</span><br><span class=line>           	&#125; <span class=keyword>else</span> &#123;</span><br><span class=line>              	<span class=comment>//折半区在高半区</span></span><br><span class=line>  				low = m + <span class=number>1</span>;</span><br><span class=line>          	&#125;</span><br><span class=line>		&#125;</span><br><span class=line>      	<span class=comment>//记录后移</span></span><br><span class=line>      	<span class=keyword>for</span> (j = i - <span class=number>1</span>; j &gt;= high +<span class=number>1</span>; j--) &#123;</span><br><span class=line>  			L.r[j+<span class=number>1</span>] = L.r[j];</span><br><span class=line>        &#125;</span><br><span class=line>      	<span class=comment>//插入</span></span><br><span class=line>      	L.r[high+<span class=number>1</span>] = L.r[<span class=number>0</span>];</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=4-3-3-效率分析><a href=#4-3-3-效率分析 class=headerlink title="4.3.3 效率分析"></a>4.3.3 效率分析</h3><blockquote><p>折半插入排序算法是一种稳定的排序算法，比直接插入算法明显减少了关键字之间比较的次数，因此速度比<code>直接插入排序</code>算法快，但记录移动的次数没有变，所以折半插入排序算法的时间复杂度仍然为<code>O(n^2)</code>，与直接插入排序算法相同。附加空间<code>O(1)</code>。</p><p>折半查找只是减少了比较次数，但是元素的移动次数不变，所以时间复杂度为<code>O(n^2)</code>。</p></blockquote><h2 id=4-4-冒泡排序-稳定><a href=#4-4-冒泡排序-稳定 class=headerlink title="4.4 冒泡排序:稳定"></a>4.4 冒泡排序:<em>稳定</em></h2><h3 id=4-4-1-说明><a href=#4-4-1-说明 class=headerlink title="4.4.1 说明"></a>4.4.1 说明</h3><h3><a href=# class=headerlink></a><center><img src=https://i.loli.net/2018/09/30/5bb06cffbba9c.gif alt=sort4></center></h3><p>是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢<strong>浮</strong>到数列的顶端。</p><h3 id=4-4-2-代码><a href=#4-4-2-代码 class=headerlink title="4.4.2 代码"></a>4.4.2 代码</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>bubble_sort</span><span class=params>(<span class=keyword>int</span> a[], <span class=keyword>int</span> n)</span> </span>&#123;</span><br><span class=line>    <span class=keyword>int</span> i, j, temp;</span><br><span class=line>    <span class=keyword>for</span> (j = <span class=number>0</span>; j &lt; n - <span class=number>1</span>; j++)</span><br><span class=line>        <span class=keyword>for</span> (i = <span class=number>0</span>; i &lt; n - <span class=number>1</span> - j; i++) &#123;</span><br><span class=line>            <span class=keyword>if</span>(a[i] &gt; a[i + <span class=number>1</span>]) &#123;</span><br><span class=line>                temp = a[i];</span><br><span class=line>                a[i] = a[i + <span class=number>1</span>];</span><br><span class=line>                a[i + <span class=number>1</span>] = temp;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=4-4-3-效率分析><a href=#4-4-3-效率分析 class=headerlink title="4.4.3 效率分析"></a>4.4.3 效率分析</h3><blockquote><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数和记录移动次数均达到最小值。所以，冒泡排序最好的时间复杂度为<code>O(n)</code>.</p><p>若初始文件是反序的，需要进行<code>n-1</code>趟排序。每趟排序要进行<code>n-i</code>次关键字的比较<code>(1≤i≤n-1)</code>，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p><center><img src=https://i.loli.net/2019/06/14/5d0397adee98870969.png></center><center><img src=https://i.loli.net/2019/06/14/5d0397be10a5685845.png></center><p>冒泡排序的最坏时间复杂度为<code>O(n^2)</code>.<br>综上，因此冒泡排序总的平均时间复杂度为<code>O(n^2)</code>.</p></blockquote><h2 id=4-5-希尔排序-不稳定><a href=#4-5-希尔排序-不稳定 class=headerlink title="4.5 希尔排序:不稳定"></a>4.5 希尔排序:<em>不稳定</em></h2><h3 id=4-5-1-说明><a href=#4-5-1-说明 class=headerlink title="4.5.1 说明"></a>4.5.1 说明</h3><p><strong>希尔排序</strong>，也称<strong>递减增量</strong>排序算法，是<strong>插入排序</strong>的一种更高效的改进版本。希尔排序是不稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li></ul><ul><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序</p><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p><p>其排序过程图如下:</p><center><img src=https://i.loli.net/2018/09/30/5bb06d2c60614.gif alt=sort5></center><h3 id=4-5-2-代码><a href=#4-5-2-代码 class=headerlink title="4.5.2 代码"></a>4.5.2 代码</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>ShellInsert</span> <span class=params>(SqList &amp;L, <span class=keyword>int</span> dk)</span> </span>&#123;</span><br><span class=line>	<span class=comment>//对顺序表L做一趟希尔插入排序。与直接插入排序相比:</span></span><br><span class=line>  	<span class=comment>// 1. 前后记录位置增量为dk</span></span><br><span class=line>  	<span class=comment>// 2. r[0]只是暂存单元，不是哨兵。当j &lt;= 0时，插入位置已经找到。</span></span><br><span class=line>  	<span class=keyword>for</span> (i = dk + <span class=number>1</span>; i &lt;= L.length; i++) &#123;</span><br><span class=line>  		<span class=keyword>if</span> (L.r[i].key &lt; L.r[i - dk].key) &#123;	<span class=comment>//需要将L.r[i]插入有序增量子序列</span></span><br><span class=line>  			L.r[<span class=number>0</span>] = L.r[i];				<span class=comment>//暂存在r[0]</span></span><br><span class=line>          	<span class=keyword>for</span> (j = i - dk; j &gt;<span class=number>0</span> &amp;&amp; L.r[<span class=number>0</span>].key &lt; L.r[j].key; j-= dk) &#123;</span><br><span class=line>  				L.r[j + dk] = L.r[j];		<span class=comment>//记录后移，查找插入位置</span></span><br><span class=line>			&#125;</span><br><span class=line>        	L.r[j+dk] = L.r[<span class=number>0</span>];				<span class=comment>//插入</span></span><br><span class=line>		&#125;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>ShellSort</span> <span class=params>(SqList &amp;L, <span class=keyword>int</span> dlta[], <span class=keyword>int</span> t)</span> </span>&#123;</span><br><span class=line>  	<span class=comment>//使用增量序列dlta[0..t-1]对顺序表L做希尔排序</span></span><br><span class=line>  	<span class=keyword>for</span> (k = <span class=number>0</span>; k &lt; t; k++) &#123;</span><br><span class=line>  		ShellInsert(L, dlta[k]);</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=4-5-3-效率分析><a href=#4-5-3-效率分析 class=headerlink title="4.5.3 效率分析"></a>4.5.3 效率分析</h3><p><strong>增量</strong>的选择是希尔排序的重要部分。只要最增量长为1任何增量序列都可以工作。算法最开始以一定的增量进行排序。然后会继续以一定增量进行排序，最终算法以增量为1进行排序。当增量为1时，算法变为插入排序，这就保证了数据一定会被排序。</p><p>Donald Shell最初建议增量选择为<code>2/n</code>并且对增量取<strong>半</strong>直到增量达到1。虽然这样取可以比<code>O(n^2)</code>类的算法（<em>插入排序</em>）更好，但这样仍然有减少平均时间和最差时间的余地。可能<strong>希尔排序</strong>最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以增量5进行了排序然后再以增量3进行排序，那么该数列不仅是以增量3有序，而且是以增量5有序。如果不是这样，那么算法在<em>迭代</em>过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p><h2 id=4-6-归并排序-稳定><a href=#4-6-归并排序-稳定 class=headerlink title="4.6 归并排序:稳定"></a>4.6 归并排序:<em>稳定</em></h2><h3 id=4-6-1-说明><a href=#4-6-1-说明 class=headerlink title="4.6.1 说明"></a>4.6.1 说明</h3><center><img src=https://i.loli.net/2018/09/30/5bb06d4246832.gif alt=sort6></center><p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><ul><li>迭代法<ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol></li></ul><ul><li>递归法<ol><li>将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li><li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li><li>重复步骤2，直到所有元素排序完毕</li></ol></li></ul><h3 id=4-6-2-代码><a href=#4-6-2-代码 class=headerlink title="4.6.2 代码"></a>4.6.2 代码</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line></span><br><span class=line></span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class=paginator><a href="/2016/android-translucent-status/" class=prev>PREV</a><a href="/2016/Retrofit2-learn/" class=next>NEXT</a></div><script>var comments = 'true';
if (comments === 'true') {
    (function() {
        var vl = document.createElement('script');
        vl.src = '//cdn1.lncld.net/static/js/3.0.4/av-min.js';
        vl.async = true;
        (document.getElementsByTagName('head')[0] 
        || document.getElementsByTagName('body')[0]).appendChild(vl);
        var vl2 = document.createElement('script');
        vl2.src = '//unpkg.com/valine/dist/Valine.min.js';
        vl2.async = true;
        (document.getElementsByTagName('head')[0] 
        || document.getElementsByTagName('body')[0]).appendChild(vl2);
        var commitDiv = document.createElement('div');
        commitDiv.id='comment';
        document.getElementsByTagName('footer')[0].appendChild(commitDiv);
    })();
}</script><div class=copyright><p>© 2015 - 2021 <a href=https://imrhj.cn>Hexer</a>, <a href="http://beian.miit.gov.cn/" target=_blank>皖ICP备16006159号-1</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity=sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW crossorigin=anonymous></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-109294877-1",'auto');ga('send','pageview');</script><script>var comments = 'true';
if (comments === 'true') {
    (function() {
        let _tt = 20;
        let _tc = setInterval(() => {
            try {
                new Valine({
                    el: '#comment' ,
                    notify:false, 
                    verify:false, 
                    appId: 'lMIQlAfa6UoprWfiEDOceMSz-gzGzoHsz',
                    appKey: 'KiGYzc5UupBdbac67AJA54dJ',
                    placeholder: '来都来了，说点啥不 ٩(●˙▿˙●)۶…⋆ฺ',
                    path:window.location.pathname, 
                    avatar:'identicon',
                    guest_info: ['nick','link']
                });
                clearInterval(_tc)
            } catch(e) {
                _tt--;
                if (_tt < 1) {
                    clearInterval(_tc)
                }
            }
        }, 500)
    })();
}</script></body></html>